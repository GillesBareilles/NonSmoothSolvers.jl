var documenterSearchIndex = {"docs":
[{"location":"VUalg/#VU-algorithm","page":"VU-algorithm","title":"VU algorithm","text":"","category":"section"},{"location":"VUalg/","page":"VU-algorithm","title":"VU-algorithm","text":"Notes on the VU algorithm of ","category":"page"},{"location":"VUalg/","page":"VU-algorithm","title":"VU-algorithm","text":"Mifflin, Sagastizábal (2005) A VU-algorithm for Convex Minimization, Mathematical Programming.","category":"page"},{"location":"VUalg/#Types","page":"VU-algorithm","title":"Types","text":"","category":"section"},{"location":"VUalg/","page":"VU-algorithm","title":"VU-algorithm","text":"NonSmoothSolvers.VUbundle\nNonSmoothSolvers.VUbundleState","category":"page"},{"location":"VUalg/#NonSmoothSolvers.VUbundle","page":"VU-algorithm","title":"NonSmoothSolvers.VUbundle","text":"Parameters:\n\nϵ: overall precision required\nm: sufficient decrease parameter\nμmin: minimal prox parameter (μ is inverse of γ). Higher μ means smaller serious steps, but less null steps\n\n\n\n\n\n","category":"type"},{"location":"VUalg/#NonSmoothSolvers.VUbundleState","page":"VU-algorithm","title":"NonSmoothSolvers.VUbundleState","text":"Parameters:\n\nσ: in (0, 0.5!], lower values enforce higher precision on each prox point approximation,\n\n\n\n\n\n","category":"type"},{"location":"VUalg/#Methods","page":"VU-algorithm","title":"Methods","text":"","category":"section"},{"location":"VUalg/","page":"VU-algorithm","title":"VU-algorithm","text":"NonSmoothSolvers.qNewtonupdate!","category":"page"},{"location":"VUalg/#NonSmoothSolvers.qNewtonupdate!","page":"VU-algorithm","title":"NonSmoothSolvers.qNewtonupdate!","text":"qNewtonupdate!(H, pₖ, pₖ₋₁, sₖ, sₖ₋₁, U, k, curvmin, ν, νlow, μ, kase; printlev) -> Tuple{Any, Any, Any}\n\n\nUpdate the quasi-Newton H matrix from updates pₖ, pₖ₋₁, sₖ, sₖ₋₁ with BFGS or SR1 scheme.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = NonSmoothSolvers","category":"page"},{"location":"#NonSmoothSolvers","page":"Home","title":"NonSmoothSolvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for NonSmoothSolvers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"NonSmoothSolvers.OptimizerParams\nNonSmoothSolvers.OptimizationState\nNonSmoothSolvers.optimize!","category":"page"},{"location":"#NonSmoothSolvers.OptimizerParams","page":"Home","title":"NonSmoothSolvers.OptimizerParams","text":"OptimizerParams\n\nGeneric parameters for optim algs\n\n\n\n\n\n","category":"type"},{"location":"#NonSmoothSolvers.OptimizationState","page":"Home","title":"NonSmoothSolvers.OptimizationState","text":"OptimizationState\n\nStores information after one iteration of the optimizer. Generic information is stored explicitly in the struct, custom information may be stored in the field additionalinfo::NamedTuple.\n\n\n\n\n\n","category":"type"},{"location":"#NonSmoothSolvers.optimize!","page":"Home","title":"NonSmoothSolvers.optimize!","text":"optimize!(pb, optimizer::NonSmoothSolvers.Optimizer, initial_x; state, optimstate_extensions, optparams) -> Tuple{Any, Any}\n\n\nCall the optimizer on problem pb, with initial point initial_x. Returns a tuple containing the final iterate vector and a trace.\n\nFeatures:\n\ntiming of the update_iterate method only;\nsaves basic information of each iteration in a vector of OptimizationState, the so-called trace;\nthe information saved at each iterate may be enriched by the user by providing a name and callback function via the optimstate_extension argument.\n\nExample\n\ngetx(o, os) = os.x\noptimstate_extensions = OrderedDict{Symbol, Function}(:x => getx)\n\noptimize!(pb, o, xclose; optparams, optimstate_extensions)\n\n\n\n\n\n","category":"function"},{"location":"#Gradient-sampling","page":"Home","title":"Gradient sampling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NonSmoothSolvers.GradientSampling","category":"page"},{"location":"#NonSmoothSolvers.GradientSampling","page":"Home","title":"NonSmoothSolvers.GradientSampling","text":"Gradient sampling algorthm.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"<!– NonSmoothSolvers.update_iterate!(state, gs::GradientSampling, pb) –>","category":"page"},{"location":"#Non-smooth-BFGS","page":"Home","title":"Non smooth BFGS","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NonSmoothSolvers.linesearch_nsbfgs","category":"page"},{"location":"#NonSmoothSolvers.linesearch_nsbfgs","page":"Home","title":"NonSmoothSolvers.linesearch_nsbfgs","text":"linesearch_nsbfgs\n\nNonsmooth linesearch from Nonsmooth optimization via quasi-Newton methods, Lewis & Overton, 2013.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"<!– NonSmoothSolvers.update_iterate! –>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<!– @autodocs --> <!-- Modules = [NonSmoothSolvers] --> <!-- pages = [\"NonSmoothSolvers.jl\", \"optimize.jl\", \"solver_types.jl\"] --> <!-- –>","category":"page"}]
}
